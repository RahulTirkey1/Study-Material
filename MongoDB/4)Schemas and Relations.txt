Datatypes:-
------------
     Type                    Example
    -------                  -----------
1)  String                     "Max"
2)  Boolean                  true/false
3)  Number
  a) Integer(32 bit)         66
  b) NumberLong(64 bit)      65565646846566                  //But if number would be greater than 64 bit,then we have to store them like text.
  c) NumberDecimal           45.78
4)  ObjectId                 ObjectId("cbhjjsjajwbjbwkak")          //Automatically Generated by Mongo whenever new document is added.
5)  ISODate                  ISODate("2020-02-03")
6)  Timestamp                Timestamp(114214532)
7)  Embedded Document        {"a":{...}}
8)  Array                    {"a":[...]}

To add a date and time,
C:\>db.products.insertOne({name:"Book",price:122,date:new Date(),time:new Timestamp()})

By default,if we use number then it prefers 64 bit,to shrink its size and specifically store low size,
C:\>db.products.insertOne({a:NumberInt(5)})

To Log the details of the database like collections,average memory size,indexes,etc,
C:\>db.stats()

To particularly check the type of datatypes,we can use,
C:\>typeof db.products.findOne().a       // It will display "number" as we have filled the data above.

OneToOne(Embedded),
C:\>db.persons.insertOne({name:"Max",age:29,car:{type:"F1 series",brand:"Mclaren"}})

OneToOne(Reference),
C:\>db.persons.insertOne({name:"Max",age:32,_id:"max_car"})
C:\>db.cars.insertOne({name:"max_car",type:"BMW"})

OneToMany(Embedded),
C:\>db.questionThreads.insertOne({name:"Max",question:"What are the popular operating systems",answer:[{text:"Windows"},{text:"MacOs"},{text:"Linux"}]})

OneToMany(References),
C:\>db.cities.insertOne({name:"New York",_id="NYC",location:{lat:"34",lon:""87}})
C:\>db.citizens.insertMany([{name:"Max",city:"NYC"},{name:"Sam",city:"NYC"}])

ManyToMany(Embedded),
C:\>db.products.insertOne({name:"Book",price:200})
C:\>db.customers.insertOne({name:"Max",cart:{name:"Book",price:200,quantity:4}})   //Here multiple users can have that same book.

ManyToMany(Reference),
C:\>db.authors.insertMany([{name:"Tom",_id:"tom",age:22},{name:"Jerry",_id:"jerry",age:20}])
C:\>db.books.insertOne({name:"Tom and Jerry",price:150,author:["tom","jerry"]})

Merging related documents using $lookup
db.books.aggregate([{$lookup: {from:"authors",localField:"author",foreignField:"_id",as:"creators"}}]).pretty()        //Here from is which collection to merge,localField is where can be the references to other collections be founded,foreignField is generally the "_id",as is the alias name.
The alias name actually merges the properties of the other collection.

Schema Validation
-------------------------------
While we directly create a collection by inserting elements,but that is not an efficient way.To add schema validation we create collection and attach validation like this
db.createCollection('posts', {
  validator: {
    $jsonSchema: {                   
      bsonType: 'object',
      required: ['title', 'text', 'creator', 'comments'],
      properties: {
        title: {
          bsonType: 'string',
          description: 'must be a string and is required'
        },
        text: {
          bsonType: 'string',
          description: 'must be a string and is required'
        },
        creator: {
          bsonType: 'objectId',
          description: 'must be an objectid and is required'
        },
        comments: {
          bsonType: 'array',
          description: 'must be an array and is required',
          items: {
            bsonType: 'object',
            required: ['text', 'author'],
            properties: {
              text: {
                bsonType: 'string',
                description: 'must be a string and is required'
              },
              author: {
                bsonType: 'objectId',
                description: 'must be an objectid and is required'
              }
            }
          }
        }
      }
    }
  }
});
//jsonSchema is a built in validator template.
//bsonType is the datatype which the value should be constrained to if mentioned string and we pass integer then it will throw an error.

Now if we want to change the validation schema after the collection is created then,
db.runCommand({
  collMod: 'posts',
  validator: {
    $jsonSchema: {
      bsonType: 'object',
      required: ['title', 'text', 'creator', 'comments'],
      properties: {
        title: {
          bsonType: 'string',
          description: 'must be a string and is required'
        },
        text: {
          bsonType: 'string',
          description: 'must be a string and is required'
        },
        creator: {
          bsonType: 'objectId',
          description: 'must be an objectid and is required'
        },
        comments: {
          bsonType: 'array',
          description: 'must be an array and is required',
          items: {
            bsonType: 'object',
            required: ['text', 'author'],
            properties: {
              text: {
                bsonType: 'string',
                description: 'must be a string and is required'
              },
              author: {
                bsonType: 'objectId',
                description: 'must be an objectid and is required'
              }
            }
          }
        }
      }
    }
  },
  validationAction: 'warn'
});
Here we have given the validationAction is to "warn",it can also be "error".So, the previous documents will get a warn that the validation schema is changed according to "warn".We can check that through the log.

  