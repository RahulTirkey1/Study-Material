Stream represents a sequence of objects from a source, which supports aggregate operations.
Following are the characteristics of a Stream −

1)Sequence of elements − A stream provides a set of elements of specific type in a sequential manner. A stream gets/computes elements on demand. 
                         It never stores the elements.
2)Source − Stream takes Collections, Arrays, or I/O resources as input source.
3)Aggregate operations − Stream supports aggregate operations like filter, map, limit, reduce, find, match, and so on.
4)Pipelining − Most of the stream operations return stream itself so that their result can be pipelined. 
               These operations are called intermediate operations and their function is to take input, process them, and return output to the target.
               collect() method is a terminal operation which is normally present at the end of the pipelining operation to mark the end of the stream.
5)Automatic iterations − Stream operations do the iterations internally over the source elements provided, in contrast to Collections where explicit iteration is required.


With Java 8, Collection interface has two methods to generate a Stream:-

1)stream() − Returns a sequential stream considering collection as its source.
2)parallelStream() − Returns a parallel Stream considering collection as its source.

Example:-
List<String> strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl");
List<String> filtered = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.toList());

forEach:-
Stream has provided a new method ‘forEach’ to iterate each element of the stream. The following code segment shows how to print 10 random numbers using forEach.
Random random = new Random();
random.ints().limit(10).forEach(System.out::println);

map:-
The ‘map’ method is used to map each element to its corresponding result.
The following code segment prints unique squares of numbers using map.
List<Integer> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);
//get list of unique squares
List<Integer> squaresList = numbers.stream().map( i -> i*i).distinct().collect(Collectors.toList());    //Due to distinct() it returns only unique numbers.

Statistics:-
With Java 8, statistics collectors are introduced to calculate all statistics when stream processing is being done.
List numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);
IntSummaryStatistics stats = numbers.stream().mapToInt((x) -> x).summaryStatistics();       //IntSummaryStatistics is a special type of class.
System.out.println("Highest number in List : " + stats.getMax());
System.out.println("Lowest number in List : " + stats.getMin());
System.out.println("Sum of all numbers : " + stats.getSum());
System.out.println("Average of all numbers : " + stats.getAverage());

filter:-
The ‘filter’ method is used to eliminate elements based on a criteria. The following code segment prints a count of empty strings using filter.
List<String>strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl");
//get count of empty string
int count = strings.stream().filter(string -> string.isEmpty()).count();

reduce:-
The reduce method is used to reduce the elements of a stream to a single value.
The reduce method takes a BinaryOperator as a parameter.
Example 1
List number = Arrays.asList(2,3,4,5);
int even = number.stream().filter(x->x%2==0).reduce(0,(ans,i)-> ans+i);

Example 2:-
// This is more compact approach for filtering data  
        Float totalPrice = productsList.stream()  
                    .map(product->product.price)  
                    .reduce(0.0f,(sum, price)->sum+price);   // accumulating price  
        System.out.println(totalPrice);  
        // More precise code   
        float totalPrice2 = productsList.stream()  
                .map(product->product.price)  
                .reduce(0.0f,Float::sum);   // accumulating price, by referring method of Float class  
        System.out.println(totalPrice2);  

For iterating:-
Stream.iterate(1, element->element+1)  
      .filter(element->element%5==0)  
      .limit(5)  
      .forEach(System.out::println);

Sum by Collector method:- 
// Using Collectors's method to sum the prices.  
        double totalPrice3 = productsList.stream()  
                        .collect(Collectors.summingDouble(product->product.price));  
        System.out.println(totalPrice3);    